# Sample Payment API Configuration
# Demonstrates: Product + Routes + PolicyBundles with multi-tier plans

---
apiVersion: apx/v1
kind: Product
metadata:
  name: payments
  regionAffinity: [us, eu]
  labels:
    team: platform
    compliance: pci-dss
    environment: production
spec:
  description: "Payment processing API with PCI-DSS compliance and multi-region support"

  plans:
    - name: free
      rateLimit:
        rps: 10
        burst: 20
        window: 1s
      quota:
        daily: 1000
      concurrency: 5
      isolation: shared
      residency: GLOBAL
      observability:
        logSampleRate: 0.01
        traceSampleRate: 0.01

    - name: pro
      rateLimit:
        rps: 200
        burst: 400
        window: 1s
      quota:
        daily: 100000
        monthly: 2000000
      concurrency: 50
      isolation: namespace
      residency: US
      features:
        - webhooks
        - batch-processing
      slo:
        availability: "99.95%"
        latency_p99_ms: 100
      observability:
        logSampleRate: 0.05
        traceSampleRate: 0.1

    - name: enterprise
      rateLimit:
        rps: 5000
        burst: 10000
        window: 1s
      concurrency: 500
      isolation: dedicated
      residency: EU
      features:
        - webhooks
        - batch-processing
        - priority-support
        - custom-slos
        - dedicated-ips
      slo:
        availability: "99.99%"
        latency_p99_ms: 50
      observability:
        logSampleRate: 0.1
        traceSampleRate: 0.2
        piiSafe: true

  authentication:
    required: true
    methods: [jwt, apikey]

---
apiVersion: apx/v1
kind: PolicyBundle
metadata:
  name: pb-pay-v1
  version: 1.2.0
  compat: backward
  labels:
    product: payments
    compliance: pci-dss
spec:
  auth:
    required: true
    jwt:
      jwksUri: https://auth.example.com/.well-known/jwks.json
      issuer: https://auth.example.com
      audience: [payments-api, payments-api-v1]
      clockSkew: 30s
    apiKey:
      header: X-API-Key
      queryParam: api_key

  authorization:
    rego: |
      package apx.authz

      import future.keywords.if

      default allow := false

      # Allow if JWT has required scope
      allow if {
        input.jwt.scope[_] == "payments:write"
        valid_plan
      }

      # Allow if API key matches tenant
      allow if {
        input.apiKey
        input.tenant.status == "active"
        valid_plan
      }

      # Check plan validity
      valid_plan if {
        input.tenant.plan in ["free", "pro", "enterprise"]
        not input.tenant.suspended
      }

      # Deny if tenant exceeded quota
      allow := false if {
        input.tenant.quota_exceeded
      }

  quotas:
    perTenant:
      window: 60s
      limit: 10000
    perKey:
      window: 1s
      limit: 100

  rateLimit:
    algorithm: sliding-window
    redis:
      enabled: true
      keyPrefix: "apx:rl:payments:"

  transforms:
    - wasm: redact-pii@sha256:abc123def456...
      phase: post-auth
      config:
        fields:
          - email
          - phone
          - ssn
          - credit_card
        redactWith: "[REDACTED]"

  observability:
    sampleRate: 0.02
    piiSafe: true
    piiFields:
      - $.customer.email
      - $.payment.card_number
      - $.payment.cvv
      - $.billing.ssn
    metrics:
      enabled: true
      labels:
        - tenant_tier
        - route
        - status_code
    tracing:
      enabled: true
      sampleRate: 0.05
      alwaysTrace:
        - tenant-debug-123

  security:
    requestSizeLimit: 5MB
    validateContentType: true
    ipAllowlist:
      - 10.0.0.0/8
      - 172.16.0.0/12
      - 192.168.0.0/16
    csrfProtection: false

  cache:
    enabled: true
    ttl: 5m
    varyBy: [tenant, path]
    redis:
      enabled: true

---
apiVersion: apx/v1
kind: Route
metadata:
  name: pay-create
  labels:
    product: payments
    version: v1
    method: write
spec:
  match:
    host: api.example.com
    path: /v1/payments
    methods: [POST]

  backend:
    pool: payments-cpu
    timeoutMs: 30000
    retries:
      maxAttempts: 2
      retryOn: [5xx, timeout]
    loadBalancing: consistent-hash

  policyBundleRef: pb-pay-v1@1.2.0

  circuitBreaker:
    enabled: true
    errorThreshold: 10
    timeout: 60s

  cors:
    enabled: true
    allowOrigins:
      - https://dashboard.example.com
      - https://app.example.com
    allowMethods: [POST, OPTIONS]
    allowHeaders:
      - Authorization
      - Content-Type
      - X-Request-ID
    maxAge: 24h

---
apiVersion: apx/v1
kind: Route
metadata:
  name: pay-get
  labels:
    product: payments
    version: v1
    method: read
spec:
  match:
    host: api.example.com
    path: /v1/payments/**
    methods: [GET]

  backend:
    pool: payments-cpu
    timeoutMs: 15000
    retries:
      maxAttempts: 3
      retryOn: [5xx, timeout]
    loadBalancing: round-robin

  policyBundleRef: pb-pay-v1@1.2.0

  circuitBreaker:
    enabled: true
    errorThreshold: 15
    timeout: 30s

  cors:
    enabled: true
    allowOrigins:
      - https://dashboard.example.com
      - https://app.example.com
    allowMethods: [GET, OPTIONS]
    allowHeaders:
      - Authorization
      - Content-Type
    maxAge: 24h

---
apiVersion: apx/v1
kind: Route
metadata:
  name: pay-webhook
  labels:
    product: payments
    version: v1
    method: webhook
spec:
  match:
    host: api.example.com
    path: /v1/payments/webhooks/**
    methods: [POST]

  backend:
    pool: payments-async
    timeoutMs: 5000
    retries:
      maxAttempts: 0  # No retries for webhooks
    loadBalancing: round-robin

  policyBundleRef: pb-pay-v1@1.2.0

  circuitBreaker:
    enabled: true
    errorThreshold: 20
    timeout: 120s
